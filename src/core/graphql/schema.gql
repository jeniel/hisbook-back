# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AuditLog {
  action: String
  id: ID!
  remarks: String
  ticket: Ticket
  ticketId: String
  timestamp: DateTime!
  updatedBy: String
  user: User
  userId: String
}

input AuditLogListRelationFilter {
  every: AuditLogWhereInput
  none: AuditLogWhereInput
  some: AuditLogWhereInput
}

input AuditLogWhereInput {
  AND: [AuditLogWhereInput!]
  NOT: [AuditLogWhereInput!]
  OR: [AuditLogWhereInput!]
  action: StringNullableFilter
  id: StringFilter
  remarks: StringNullableFilter
  ticket: TicketNullableScalarRelationFilter
  ticketId: StringNullableFilter
  timestamp: DateTimeFilter
  updatedBy: StringNullableFilter
  user: UserNullableScalarRelationFilter
  userId: StringNullableFilter
}

input BatchSearchInput {
  collectionName: String!
  searches: [SearchPointsInput!]!
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

type CensusSummary {
  departmentsWithUserCount: [DepartmentUserCount!]!
  ticketByUserId: [TicketStatusCount!]
  ticketsByStatus: [TicketStatusCount!]!
  totalDepartments: Int!
  totalEvents: Int!
  totalPosts: Int!
  totalTickets: Int!
  totalTicketsByUserId: Int
  totalUsers: Int!
}

input ChatInput {
  question: String!
  userId: String!
}

type ChatMessage {
  assistant: String!
  user: String!
}

type ChatResponse {
  answer: String!
  history: [ChatMessage!]!
  question: String!
}

input CreateCollectionInput {
  distance: String! = "Cosine"
  name: String!
  size: Int!
}

input CreateDepartmentInput {
  description: String!
  isSupport: Boolean
  name: String!
}

input CreateEventInput {
  detailsUrl: String
  endDate: DateTime
  location: String!
  startDate: DateTime
  title: String!
}

input CreateIndexInput {
  collectionName: String!
  fieldName: String!
  fieldSchema: String! = "keyword"
}

input CreatePostInput {
  content: String!
  images: [String!]
  userId: String
}

input CreateProfileInput {
  address: String
  avatar: String
  birthDate: DateTime
  contact: String
  departmentId: String
  employeeID: String
  firstName: String
  gender: Gender
  lastName: String
  middleName: String
  title: String
  userId: String
}

input CreateTicketInput {
  createdById: String!
  departmentId: String!
  floor: String
  message: String
  missedAt: DateTime
  remarks: String
  screenshot: String
  status: Status
  subject: String!
  updatedBy: String
}

input CreateUserInput {
  departmentId: String
  email: String
  password: String!
  role: [Role!]
  username: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

type Department {
  _count: DepartmentCount!
  createdAt: DateTime!
  deletedAt: DateTime
  description: String!
  id: ID!
  isSupport: Boolean!
  name: String!
  tickets: [Ticket!]
  users: [User!]
}

type DepartmentCount {
  tickets: Int!
  users: Int!
}

type DepartmentDropdown {
  description: String!
  id: String!
  isSupport: Boolean
  name: String!
}

type DepartmentList {
  data: [Department!]!
  isSupport: Boolean!
  meta: Meta
}

input DepartmentNullableScalarRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

input DepartmentScalarRelationFilter {
  is: DepartmentWhereInput
  isNot: DepartmentWhereInput
}

type DepartmentUserCount {
  departmentDescription: String!
  departmentId: String!
  departmentName: String!
  userCount: Int!
}

input DepartmentWhereInput {
  AND: [DepartmentWhereInput!]
  NOT: [DepartmentWhereInput!]
  OR: [DepartmentWhereInput!]
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  description: StringFilter
  id: StringFilter
  isSupport: BoolFilter
  name: StringFilter
  tickets: TicketListRelationFilter
  users: UserListRelationFilter
}

input DocumentToEmbedInput {
  content: String!
  documentType: String!
  id: String
  metadata: JSON
}

input EnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input EnumRoleNullableListFilter {
  equals: [Role!]
  has: Role
  hasEvery: [Role!]
  hasSome: [Role!]
  isEmpty: Boolean
}

input EnumStatusFilter {
  equals: Status
  in: [Status!]
  not: NestedEnumStatusFilter
  notIn: [Status!]
}

type Event {
  createdAt: DateTime!
  deletedAt: DateTime
  detailsUrl: String
  endDate: DateTime
  id: ID!
  location: String!
  startDate: DateTime
  title: String!
}

type EventList {
  data: [Event!]!
  meta: Meta
}

input EventWhereInput {
  AND: [EventWhereInput!]
  NOT: [EventWhereInput!]
  OR: [EventWhereInput!]
  createdAt: DateTimeFilter
  deletedAt: DateTimeNullableFilter
  detailsUrl: StringNullableFilter
  endDate: DateTimeNullableFilter
  id: StringFilter
  location: StringFilter
  startDate: DateTimeNullableFilter
  title: StringFilter
}

enum Gender {
  Female
  Male
  Others
}

type GeneralMsg {
  message: String!
  success: Boolean
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type MeQuery {
  isSignedIn: Boolean!
  user: User!
}

type Meta {
  currentPage: Float!
  lastPage: Float!
  next: Float
  perPage: Float!
  prev: Float
  total: Float!
}

type Mutation {
  ask(input: ChatInput!): ChatResponse!
  createDepartment(payload: CreateDepartmentInput!): GeneralMsg!
  createEvent(payload: CreateEventInput!): GeneralMsg!
  createPost(payload: CreatePostInput!): GeneralMsg!
  createProfile(payload: CreateProfileInput!): GeneralMsg!
  createQdrantCollection(input: CreateCollectionInput!): Boolean!
  createQdrantIndex(input: CreateIndexInput!): Boolean!
  createTicket(payload: CreateTicketInput!): GeneralMsg!
  createUser(payload: CreateUserInput!): GeneralMsg!
  deleteDepartment(id: String!): GeneralMsg!
  deleteEvent(id: String!): GeneralMsg!
  deletePost(postId: String!): GeneralMsg!
  deleteProfile(id: String!): GeneralMsg!
  deleteQdrantCollection(name: String!): Boolean!
  deleteQdrantPoints(collectionName: String!, ids: [ID!]!): Boolean!
  deleteTenantDocuments(collectionName: String! = "documents", tenantId: String!): String!
  deleteTicket(id: String!): GeneralMsg!
  deleteUser(id: String!): GeneralMsg!
  initializeDocumentCollection(collectionName: String!, vectorSize: Float! = 1536): Boolean!
  logOut: GeneralMsg!
  processAndStoreDocuments(input: ProcessDocumentsInput!): Boolean!
  signin(signInInput: SignInInput!): SignResponse!
  signup(signUpInput: SignUpInput!): SignResponse!
  updateDepartment(id: String!, payload: UpdateDepartmentInput!): GeneralMsg!
  updateEvent(id: String!, payload: UpdateEventInput!): GeneralMsg!
  updatePost(data: UpdatePostInput!, postId: String!): GeneralMsg!
  updateProfile(id: String!, payload: UpdateProfileInput!): GeneralMsg!
  updateTicket(id: String!, payload: UpdateTicketInput!): GeneralMsg!
  updateUser(id: String!, payload: UpdateUserInput!): GeneralMsg!
  upsertQdrantPoints(input: UpsertPointsInput!): Boolean!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumGenderNullableFilter {
  equals: Gender
  in: [Gender!]
  not: NestedEnumGenderNullableFilter
  notIn: [Gender!]
}

input NestedEnumStatusFilter {
  equals: Status
  in: [Status!]
  not: NestedEnumStatusFilter
  notIn: [Status!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Posts {
  content: String!
  datePosted: DateTime!
  id: ID!
  images: [String!]
  user: User
  userId: String
}

type PostsList {
  data: [Posts!]!
  meta: Meta
}

input PostsListRelationFilter {
  every: PostsWhereInput
  none: PostsWhereInput
  some: PostsWhereInput
}

input PostsWhereInput {
  AND: [PostsWhereInput!]
  NOT: [PostsWhereInput!]
  OR: [PostsWhereInput!]
  content: StringFilter
  datePosted: DateTimeFilter
  id: StringFilter
  images: StringNullableListFilter
  user: UserNullableScalarRelationFilter
  userId: StringNullableFilter
}

input ProcessDocumentsInput {
  collectionName: String! = "documents"
  documents: [DocumentToEmbedInput!]!
}

type Profile {
  address: String
  avatar: String
  birthDate: DateTime
  contact: String
  createdAt: DateTime!
  employeeID: String
  firstName: String
  gender: Gender
  id: ID!
  lastName: String
  middleName: String
  title: String
  updatedAt: DateTime!
  user: User
  userId: String
}

type ProfileList {
  data: [Profile!]!
  meta: Meta
}

input ProfileNullableScalarRelationFilter {
  is: ProfileWhereInput
  isNot: ProfileWhereInput
}

input ProfileWhereInput {
  AND: [ProfileWhereInput!]
  NOT: [ProfileWhereInput!]
  OR: [ProfileWhereInput!]
  address: StringNullableFilter
  avatar: StringNullableFilter
  birthDate: DateTimeNullableFilter
  contact: StringNullableFilter
  createdAt: DateTimeFilter
  employeeID: StringNullableFilter
  firstName: StringNullableFilter
  gender: EnumGenderNullableFilter
  id: StringFilter
  lastName: StringNullableFilter
  middleName: StringNullableFilter
  title: StringNullableFilter
  updatedAt: DateTimeFilter
  user: UserNullableScalarRelationFilter
  userId: StringNullableFilter
}

type QdrantBatchSearchResultType {
  results: [[QdrantSearchResultType!]!]!
}

type QdrantCollectionInfoType {
  config: JSON
  indexed_vectors_count: Int!
  payload_schema: JSON
  points_count: Int!
  status: String!
  vectors_count: Int!
}

type QdrantCollectionType {
  name: String!
}

type QdrantCountResultType {
  count: Int!
}

type QdrantHealthStatusType {
  isAvailable: Boolean!
  message: String!
  status: String!
}

input QdrantPointInput {
  id: ID!
  payload: JSON
  vector: [Float!]!
}

type QdrantPointType {
  id: ID!
  payload: JSON
  score: Float
  vector: [Float!]
  version: Int
}

type QdrantScrollResultType {
  next_page_offset: String
  points: [QdrantPointType!]!
}

type QdrantSearchResultType {
  content: String
  id: ID!
  metadata: JSON
  payload: JSON
  score: Float!
  vector: [Float!]
}

type Query {
  findAllDepartments(page: Int, perPage: Int, search: String, where: DepartmentWhereInput): DepartmentList!
  findAllEvents(page: Int, perPage: Int, search: String, where: EventWhereInput): EventList!
  findAllForDropdown: [DepartmentDropdown!]!
  findAllPosts(page: Int, perPage: Int, userId: String, where: PostsWhereInput): PostsList!
  findAllPostsCreatedByUser(page: Float, perPage: Float, userId: String!, where: PostsWhereInput): PostsList!
  findAllProfiles(page: Int, perPage: Int, where: ProfileWhereInput): ProfileList!
  findAllTickets(page: Int, perPage: Int, search: String, status: Status, where: TicketWhereInput): TicketList!
  findAllUsers(employeeID: String, page: Int, perPage: Int, search: String, where: UserWhereInput): UserList!
  findProfile(id: String!): Profile!
  findSimilarDocuments(collectionName: String! = "documents", documentId: String!, limit: Float! = 5, tenantId: String!, threshold: Float! = 0.8): [QdrantSearchResultType!]!
  findTicketbyID(id: String!): Ticket
  findTicketsByDepartment(page: Int, perPage: Int, search: String, status: Status, where: TicketWhereInput): TicketList!
  findTicketsByUser(page: Int, perPage: Int, search: String, status: Status, userId: String!, where: TicketWhereInput): TicketList!
  findTicketsWorkedByUser(page: Int, perPage: Int, search: String, status: Status, userId: String!, where: TicketWhereInput): TicketList!
  getCensusSummary(userId: String): CensusSummary!
  hybridSearch(collectionName: String! = "documents", keywords: [String!]!, limit: Float! = 10, query: String!, tenantId: String!): [QdrantSearchResultType!]!
  isEmbeddingServiceAvailable: Boolean!
  meQuery: MeQuery!
  qdrantBatchSearch(input: BatchSearchInput!): QdrantBatchSearchResultType!
  qdrantCollection(name: String!): QdrantCollectionInfoType!
  qdrantCollectionAnalytics(collectionName: String! = "documents"): String!
  qdrantCollectionExists(name: String!): Boolean!
  qdrantCollections: [QdrantCollectionType!]!
  qdrantConnectivityTest: String!
  qdrantHealth: QdrantHealthStatusType!
  qdrantPoint(collectionName: String!, id: ID!): QdrantPointType
  qdrantPoints(collectionName: String!, ids: [ID!]!): [QdrantPointType!]!
  qdrantPointsCount(collectionName: String!, filter: JSON): QdrantCountResultType!
  qdrantQueryPoints(input: SearchPointsInput!): [QdrantSearchResultType!]!
  qdrantScrollPoints(input: ScrollPointsInput!): QdrantScrollResultType!
  qdrantSearchPoints(input: SearchPointsInput!): [QdrantSearchResultType!]!
  qdrantServiceStatus: String!
  semanticSearch(input: SemanticSearchInput!): [QdrantSearchResultType!]!
}

enum QueryMode {
  default
  insensitive
}

enum Role {
  ADMIN
  USER
}

input ScrollPointsInput {
  collectionName: String!
  filter: JSON
  limit: Int! = 100
  offset: String
}

input SearchPointsInput {
  collectionName: String!
  filter: JSON
  limit: Int! = 10
  vector: [Float!]!
  withPayload: Boolean! = true
  withVector: Boolean! = false
}

input SemanticSearchInput {
  collectionName: String! = "documents"
  documentType: String
  limit: Int! = 10
  query: String!
  tenantId: String!
  threshold: Float! = 0.7
}

input SignInInput {
  email: String
  password: String!
  username: String
}

type SignResponse {
  accessToken: String!
  isSignedIn: Boolean!
  refreshToken: String!
  user: User!
}

input SignUpInput {
  designation: String
  email: String!
  firstName: String
  lastName: String
  middleName: String
  password: String!
  username: String!
}

enum Status {
  Approved
  Completed
  InProgress
  OnHold
  Pending
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableListFilter {
  equals: [String!]
  has: String
  hasEvery: [String!]
  hasSome: [String!]
  isEmpty: Boolean
}

type Ticket {
  _count: TicketCount!
  auditLogs: [AuditLog!]
  createdAt: DateTime!
  createdBy: User!
  createdById: String!
  deletedAt: DateTime
  department: Department!
  departmentId: String!
  floor: String
  id: ID!
  message: String
  missedAt: DateTime
  remarks: String
  screenshot: String
  status: Status!
  statusFormatted: String!
  subject: String!
  updatedAt: DateTime!
  updatedBy: String
}

type TicketCount {
  auditLogs: Int!
}

type TicketList {
  data: [Ticket!]!
  meta: Meta
}

input TicketListRelationFilter {
  every: TicketWhereInput
  none: TicketWhereInput
  some: TicketWhereInput
}

input TicketNullableScalarRelationFilter {
  is: TicketWhereInput
  isNot: TicketWhereInput
}

type TicketStatusCount {
  count: Int!
  status: Status!
}

input TicketWhereInput {
  AND: [TicketWhereInput!]
  NOT: [TicketWhereInput!]
  OR: [TicketWhereInput!]
  auditLogs: AuditLogListRelationFilter
  createdAt: DateTimeFilter
  createdBy: UserScalarRelationFilter
  createdById: StringFilter
  deletedAt: DateTimeNullableFilter
  department: DepartmentScalarRelationFilter
  departmentId: StringFilter
  floor: StringNullableFilter
  id: StringFilter
  message: StringNullableFilter
  missedAt: DateTimeNullableFilter
  remarks: StringNullableFilter
  screenshot: StringNullableFilter
  status: EnumStatusFilter
  subject: StringFilter
  updatedAt: DateTimeFilter
  updatedBy: StringNullableFilter
}

input UpdateDepartmentInput {
  description: String
  isSupport: Boolean
  name: String!
}

input UpdateEventInput {
  detailsUrl: String
  endDate: DateTime
  location: String!
  startDate: DateTime
  title: String!
}

input UpdatePostInput {
  content: String
  images: [String!]
  userId: String
}

input UpdateProfileInput {
  address: String
  avatar: String
  birthDate: DateTime
  contact: String
  departmentId: String
  employeeID: String
  firstName: String
  gender: Gender
  lastName: String
  middleName: String
  title: String
  userId: String
}

input UpdateTicketInput {
  createdById: String
  departmentId: String
  floor: String
  message: String
  missedAt: DateTime
  remarks: String
  screenshot: String
  status: Status
  subject: String
  updatedBy: String
}

input UpdateUserInput {
  departmentId: String
  email: String
  password: String!
  role: [Role!]
  username: String!
}

input UpsertPointsInput {
  collectionName: String!
  points: [QdrantPointInput!]!
}

type User {
  _count: UserCount!
  auditLogs: [AuditLog!]
  createdAt: DateTime
  deletedAt: DateTime
  department: Department
  departmentId: String

  """@Validator.@IsEmail()"""
  email: String
  hashedRefreshToken: String
  id: ID!
  posts: [Posts!]
  profile: Profile
  role: [Role!]
  tickets: [Ticket!]
  username: String!
}

type UserCount {
  auditLogs: Int!
  posts: Int!
  tickets: Int!
}

type UserList {
  data: [User!]!
  meta: Meta
}

input UserListRelationFilter {
  every: UserWhereInput
  none: UserWhereInput
  some: UserWhereInput
}

input UserNullableScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserScalarRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  auditLogs: AuditLogListRelationFilter
  createdAt: DateTimeNullableFilter
  deletedAt: DateTimeNullableFilter
  department: DepartmentNullableScalarRelationFilter
  departmentId: StringNullableFilter
  email: StringNullableFilter
  hashedPassword: StringFilter
  hashedRefreshToken: StringNullableFilter
  id: StringFilter
  posts: PostsListRelationFilter
  profile: ProfileNullableScalarRelationFilter
  role: EnumRoleNullableListFilter
  tickets: TicketListRelationFilter
  username: StringFilter
}